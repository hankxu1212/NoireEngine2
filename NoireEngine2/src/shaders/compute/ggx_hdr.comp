#ifndef _INCLUDE_GGX_HDR
#define _INCLUDE_GGX_HDR

layout (local_size_x = 4, local_size_y = 4, local_size_z=1) in;

// input and output are both interpreted as unsigend, normalized fixed point numbers
layout (set=0, binding = 0, rgba8) uniform readonly imageCube inputImage;
layout (set=0, binding = 1, rgba8) uniform imageCube resultImage;

#include "../glsl/cubemap.glsl"
#include "../glsl/hdr.glsl"

const uint NumSamples = 32;
const float InvNumSamples = 1.0 / float(NumSamples);
#include "../glsl/sampling.glsl"

void main()
{
    // normal direction
    ivec3 inSize = ivec3(imageSize(inputImage), 6);
    ivec3 outSize = ivec3(imageSize(resultImage), 6);
    float roughness = MIP_LEVEL * 0.2f;
    vec3 T,B;

    vec2 uv_in = gl_GlobalInvocationID.xy / vec2(outSize.xy);
    vec3 N = CubeUVtoCartesian(int(gl_GlobalInvocationID.z), uv_in);
    vec3 V = N;
    vec3 R = N;

    ComputeTangentBitangent(N, T, B);

    // Monte Carlo integration of hemispherical irradiance.
	vec3 irradiance = vec3(0);
    float totalWeight = 0;

	for(uint i=0; i<NumSamples; ++i) {
		vec2 u  = SampleHammersley(i);
		vec3 H = TangentToWorld(SampleGGX(u.x, u.y, roughness), T, N, B);
        vec3 L = 2 * dot( V, H ) * H - V;
        float NoL = saturate( dot( N, L ) );

        int face;
        vec2 uv = CartesianToCubeUV(normalize(L), face);
        vec4 sampled_rgbe = imageLoad(inputImage, ivec3(uv * inSize.xy, face));
        vec3 sampled_rgb = vec3(rgbe_f_to_float(sampled_rgbe));
		irradiance += sampled_rgb * NoL;
        totalWeight += NoL;
	}

	irradiance /= totalWeight;
    vec4 rgb_out = float_f_to_rgbe(irradiance);

    imageStore(resultImage, ivec3(gl_GlobalInvocationID.xyz), rgb_out);
}

#endif